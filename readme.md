1,打开源文件(pic.bmp),方式为二进制(rb)
2,每8个bit,以一个字节(char)的方式读取并统计字节频率,2^8=256,并输出
3,做一个256个叶子节点的哈夫曼树,用01串代替源文件
4,将01串8bit 1字节转换后,保存为压缩后的pic.bmp.huf
5,附加功能:将pic.bmp.huf解压为decompression-{{originalname}}.bmp

main.cpp:
运行用.输入需要压缩文件的完整路径,输出一系列信息包括压缩前后的文件大小以及压缩率.

huffman.h:
核心代码.
压缩:将字节-频率数组转化为哈夫曼树,并输出转换后的01串,接口返回01串.
解压:按照压缩时储存的字节-频率数组,直接将传入的01串转换为源文件字符串.
提供测试用接口,先根序输出全树.

count.h:
压缩:统计源文件的字节频率,接口返回一个字节-频率数组.
解压:源文件的字符串已经完整的由huffman.cpp得到,接口只需要原封不动的把他保存为解压后的文件decompression-{{originalname}}.bmp,放到压缩文件同目录.


com.h:
压缩:将01串压缩为最终的压缩文件.接口内部将最终的压缩文件保存至源文件同目录.
解压:将压缩文件以Bit为单位,转换成01串.注意补位头信息.

test.cpp:
测试用.本项目开发模式为测试驱动.所有的测试代码写在这里.

testcnt.bmp:
测试count.h是否ok

test01.txt:
测试com.h是否ok

pic.bmp:
上线前最终测试.运行main.cpp进行转换.
